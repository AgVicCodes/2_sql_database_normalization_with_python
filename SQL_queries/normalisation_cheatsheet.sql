-- 1st Normal form
    -- All rows must be unique
    -- All data must also be atomic and non divisible
    -- Row order must not convey any information
    -- Mutiple data types should not exist in on column
    -- All tables must have a primary key
    -- No repeated groups
 
-- 2nd normal form
    -- Deletion and update anomaly
    /* Partial dependency: Exery column in a table should depend 
        on every primary key in a multicolumnar primary key table */

-- 3rd normal form
    /* Transitive dependency: No column should depend on another 
        columns other than that of the primary key */
    
-- 4th normal form
    /* Multivalued dependency: No one to many relations 
    in more than one independent columns */


-- CREATE TABLE sales_records (
--     id SERIAL PRIMARY KEY,
--     sales_id INTEGER,
--     name VARCHAR (255),
--     email VARCHAR (255),
--     age INTEGER,
--     address VARCHAR (255),
--     country VARCHAR (255),
--     phone VARCHAR (255),
--     product VARCHAR (255),
--     quantity INTEGER,
--     status VARCHAR (255),
--     order_date DATE,
--     delivery_date DATE
-- );

-- CREATE TABLE sales_records1 (
--     sales_id INTEGER GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
--     id INTEGER,
--     name VARCHAR (255),
--     email VARCHAR (255),
--     age INTEGER,
--     address VARCHAR (255),
--     country VARCHAR (255),
--     phone VARCHAR (255),
--     product VARCHAR (255),
--     quantity INTEGER,
--     status VARCHAR (255),
--     order_date DATE,
--     delivery_date DATE
-- );

-- CREATE TABLE sales_records1 (
--     sales_id INTEGER GENERATED BY DEFAULT PRIMARY KEY,
--     id INTEGER,
--     name VARCHAR (255),
--     email VARCHAR (255),
--     age INTEGER,
--     address VARCHAR (255),
--     country VARCHAR (255),
--     phone VARCHAR (255),
--     product VARCHAR (255),
--     quantity INTEGER,
--     status VARCHAR (255),
--     order_date DATE,
--     delivery_date DATE
-- );

-- CREATE TABLE sales_records (
--     sales_id INTEGER PRIMARY KEY,
--     id INTEGER,
--     name VARCHAR (255),
--     email VARCHAR (255),
--     age INTEGER,
--     address VARCHAR (255),
--     country VARCHAR (255),
--     phone VARCHAR (255),
--     product VARCHAR (255),
--     quantity INTEGER,
--     status VARCHAR (255),
--     order_date DATE,
--     delivery_date DATE
-- );

-- ALTER TABLE sales_records
-- ADD CONSTRAINT sr_id_pk 
-- PRIMARY KEY (id);

-- pg_dump -U username -d database_name -f backup_file.sql
-- psql -U username -f backup_file.sql 

-- HANDLING DUPLICATES
-- Identify duplicate rows
-- SELECT column1, column2, COUNT(*)
-- FROM your_table
-- GROUP BY column1, column2
-- HAVING COUNT(*) > 1;

/*
CREATE PROCEDURE DynamicGroupBy
    @TableName NVARCHAR(128),
    @ColumnNames NVARCHAR(MAX)
AS
BEGIN
    DECLARE @SQL NVARCHAR(MAX);

    -- Build the dynamic SQL query
    SET @SQL = N'SELECT ' + @ColumnNames + ', COUNT(*) AS Count FROM ' + @TableName + ' GROUP BY ' + @ColumnNames;

    -- Execute the dynamic SQL query
    EXEC sp_executesql @SQL;
END; */

-- EXEC DynamicGroupBy 'your_table', 'column1, column2, column3';

SELECT *, COUNT(*) FROM sales
GROUP BY sales_id, product_id, status, quantity, order_date, delivery_date
HAVING COUNT(*) > 1
LIMIT 10;

SELECT *, COUNT(*) FROM products
GROUP BY product_id, product_name, price_in_pounds
HAVING COUNT(*) > 1
LIMIT 10;

SELECT *, COUNT(*) FROM countries
GROUP BY id, country
HAVING COUNT(*) > 1
LIMIT 10;

SELECT *, COUNT(*) FROM users
GROUP BY user_id
HAVING COUNT(*) > 1
LIMIT 10;

-- IF 0, no duplicate row found
-- Wrong
SELECT 
    CASE WHEN LENGTH(
        SELECT *, COUNT(*) FROM sales_records
        GROUP BY index, sales_id, name, email, age, address, country, phone, product, status, order_date, delivery_date
        HAVING COUNT(*) > 1
        LIMIT 10
    ) = 0 THEN 'No duplicates found'
    ELSE END;

SELECT 
    CASE 
        WHEN COUNT(*) = 0 THEN 'No duplicates found'
        ELSE COUNT(*)::VARCHAR || 'Duplicates found'
    END AS result
FROM (
    SELECT COUNT(*) 
    FROM sales_records
    GROUP BY index, sales_id, name, email, age, address, country, phone, product, status, order_date, delivery_date
    HAVING COUNT(*) > 1
) AS duplicates;



-- ALTER TABLE customers
-- ALTER COLUMN contact_name 
-- SET NOT NULL;

CREATE SEQUENCE temp_seq;

ALTER TABLE temp 
ALTER COLUMN price SET DEFAULT nextval('temp_seq');

SELECT setval('temp_seq', (COALESCE(SELECT MAX(id) FROM temp), 1));

SELECT relname AS sequence_name
FROM pg_class
WHERE relkind = 'S';

-- Calculate the Average Sales Quantity Over a 7-Day Window
-- Problem: Calculate the average sales quantity over a 7-day window for each product_id.

-- Find the Top 3 Most Recent Sales for Each Product
-- Problem: Find the top 3 most recent sales for each product_id.

-- Calculate the Difference Between Current and Previous Sale Quantity
-- Problem: Calculate the difference in quantity between the current sale and the previous sale for each product_id.

-- Find the First and Last Sale Date for Each Product
-- Problem: Find the first and last sale date for each product_id.

-- Rank Products by Total Sales
-- Problem: Rank products based on the total quantity sold, with the highest quantity getting rank 1.

-- Calculate Running Total of Sales Quantity
-- Problem: Calculate the running total of the quantity sold for each product_id in the old_sales table.